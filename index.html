<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Star Catalog — Brightest Stars</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :focus-visible {
      outline: 2px solid;
      outline-offset: 2px;
    }

    th button {
      width: 100%;
      text-align: left;
    }

    .sort-ind {
      margin-left: .25rem;
      opacity: .6;
    }

    /* Ensure table cells align content to top and fill full height */
    tbody td {
      vertical-align: top;
    }
  </style>
</head>

<body class="bg-slate-50 text-slate-900">
  <main class="max-w-full mx-auto p-6 w-full">
    <header class="mb-6">
      <h1 class="text-3xl font-bold">Interactive Star Catalog — <span id="star-count">0</span> Bright Stars</h1>
      <p class="text-slate-600 mt-2">Click a column header to sort. Use the checkboxes to include stars visible from the
        Northern and/or Southern sky. Values are approximate, rounded; luminosity in solar units (L☉), radius in solar
        radii (R☉), mass in solar masses (M☉), age in billions of years (Gyr).</p>
    </header>

    <!-- Controls -->
    <section class="mb-4 grid gap-3 md:grid-cols-4">
      <label class="inline-flex items-center gap-2 p-2 rounded-xl border border-slate-200 bg-white shadow-sm">
        <input type="checkbox" id="chkNorth" class="h-4 w-4" checked>
        <span class="text-sm font-medium">Include Northern-sky stars</span>
      </label>
      <label class="inline-flex items-center gap-2 p-2 rounded-xl border border-slate-200 bg-white shadow-sm">
        <input type="checkbox" id="chkSouth" class="h-4 w-4" checked>
        <span class="text-sm font-medium">Include Southern-sky stars</span>
      </label>
      <label class="block">
        <span class="text-sm font-medium">Search (name / constellation / notes)</span>
        <input id="q" type="search" placeholder="e.g., Vega, giant, debris disk"
          class="mt-1 w-full rounded-xl border border-slate-300 px-3 py-2 shadow-sm" />
      </label>
      <label class="block">
        <span class="text-sm font-medium">Filter by spectral type</span>
        <select id="spectralFilter" class="mt-1 w-full rounded-xl border border-slate-300 px-3 py-2 shadow-sm">
          <option value="">All</option>
          <option>A</option>
          <option>F</option>
          <option>G</option>
          <option>K</option>
          <option>M</option>
          <option>B</option>
          <option>O</option>
        </select>
      </label>
    </section>

    <!-- Table -->
    <div class="overflow-x-auto xl:overflow-visible rounded-2xl border border-slate-200 bg-white shadow-sm">
      <table class="w-full xl:table-auto text-sm" id="starTable">
        <thead class="bg-slate-100">
          <tr>
            <th class="p-3"><button data-key="name" class="font-semibold">Name<span class="sort-ind"></span></button>
            </th>
            <th class="p-3"><button data-key="constellation" class="font-semibold">Constellation<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="visibility" class="font-semibold">Visibility<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="mag" class="font-semibold">App. mag (m)<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="numStars" class="font-semibold"># Stars<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="distance" class="font-semibold">Distance (ly)<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="lum" class="font-semibold">Luminosity (L☉)<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="temp" class="font-semibold">Temperature (K)<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="radius" class="font-semibold">Radius (R☉)<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="mass" class="font-semibold">Mass (M☉)<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="age" class="font-semibold">Age (Gyr)<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="spectral" class="font-semibold">Spectral type<span
                  class="sort-ind"></span></button></th>
            <th class="p-3"><button data-key="starType" class="font-semibold">Star type<span
                  class="sort-ind"></span></button></th>
            <!-- Exoplanets column removed; planet details are shown in the Notes popup -->
            <!-- # Planets column removed per user request; planet info will be moved into Notes popup -->
            <th class="p-3" style="min-width:15rem;"><button data-key="notes" class="font-semibold">Notes<span
                  class="sort-ind"></span></button>
            </th>
          </tr>
        </thead>
        <tbody id="tbody" class="divide-y divide-slate-100"></tbody>
      </table>
    </div>

    <p class="text-xs text-slate-500 mt-3">Approximate data assembled for educational use. "Visibility" denotes which
      hemisphere(s) the star is readily observable from: <em>Northern</em>, <em>Southern</em>, or <em>Both</em>.</p>
  </main>

  <script src="stars-data.js"></script>
  <script>
    // --- Dataset (loaded from external file `stars-data.js`) ---

    // --- State ---
    let sortKey = 'name'
    let sortDir = 'asc' // 'asc' | 'desc'

    const q = document.getElementById('q')
    const chkNorth = document.getElementById('chkNorth')
    const chkSouth = document.getElementById('chkSouth')
    const spectralFilter = document.getElementById('spectralFilter')
    const tbody = document.getElementById('tbody')

    // --- Helpers ---
    function compare(a, b) {
      const va = a[sortKey]
      const vb = b[sortKey]
      // numeric vs string handling
      const na = typeof va === 'number'
      const nb = typeof vb === 'number'
      let res
      if (na && nb) res = va - vb
      else res = String(va).localeCompare(String(vb))
      return sortDir === 'asc' ? res : -res
    }

    function formatBool(b) { return b ? 'Yes' : 'No' }
    function formatNum(x) {
      if (x == null || Number.isNaN(x)) return '—'
      if (x >= 1000) return x.toLocaleString()
      return x.toString()
    }

    // Return the most-massive component's star type by inspecting the spectral string.
    function parseSpectralPart(part) {
      // Be permissive: locate the first spectral-letter (O B A F G K M)
      // anywhere in the string so forms like "dM1e", "Am", "B7?V" etc
      // are parsed correctly.
      if (!part) return null
      const s = part.toString().trim()
      const m = s.match(/([OBAFGKM])\s*([0-9]*\.?[0-9]*)/i)
      if (!m) return null
      return { letter: m[1].toUpperCase(), number: m[2] ? parseFloat(m[2]) : 0, raw: s }
    }

    function mostMassiveType(s) {
      const sp = (s.spectral || '').toString()
      if (sp.includes('+')) {
        const parts = sp.split('+').map(p => p.trim()).filter(Boolean)
        const order = { O: 0, B: 1, A: 2, F: 3, G: 4, K: 5, M: 6 }
        let best = parts[0]
        let bestRank = 999
        let bestNum = 999
        parts.forEach(p => {
          const info = parseSpectralPart(p)
          if (!info) return
          const rank = order[info.letter] === undefined ? 999 : order[info.letter]
          const num = isNaN(info.number) ? 999 : info.number
          if (rank < bestRank || (rank === bestRank && num < bestNum)) {
            best = info.raw
            bestRank = rank
            bestNum = num
          }
        })
        return best
      }
      // If there's no composite spectral string, prefer an explicit starType if it's specific;
      // otherwise fall back to the spectral field or existing starType.
      if (s.starType && !/multiple|binary|pair|complex/i.test(s.starType)) return s.starType
      return s.spectral || s.starType || '—'
    }

    function displayNumStars(s) {
      // Prefer an explicit `numStars` when provided by the data author.
      if (typeof s.numStars === 'number' && Number.isFinite(s.numStars) && s.numStars > 0) return s.numStars
      const sp = (s.spectral || '').toString()
      if (sp.includes('+')) return sp.split('+').map(p => p.trim()).filter(Boolean).length
      return 1
    }

    // Human-readable legend for uncertainty codes
    function uncertaintyText(s) {
      const legend = {
        1: 'Distance / parallax disagreement',
        2: 'Multiplicity / companions disputed',
        3: 'Spectral / luminosity disagreement',
        4: 'Physical parameter variance',
        5: 'Tentative detection'
      }
      if (!s || !s.uncertainty || !s.uncertainty.length) return ''
      return s.uncertainty.map(c => legend[c] || `Unknown (${c})`).join('; ')
    }

    // Return a color for a spectral class letter (O B A F G K M).
    function colorForSpectral(letter) {
      // Return a consistent, perceptually-ordered palette for spectral classes.
      // Palette chosen to be distinctive and reasonably accessible on light backgrounds.
      if (!letter) return '#9aa0a6' // neutral grey for unknown
      const l = letter.toUpperCase()
      const map = {
        O: '#9fbfff', // very hot: blue
        B: '#a6c8ff', // hot: pale blue
        A: '#f8fbff', // white / bluish-white
        F: '#fff7e6', // yellow-white
        G: '#fff2a8', // yellow (Sun-like)
        K: '#ffd5a8', // orange
        M: '#ff9a88'  // red
      }
      return map[l] || '#9aa0a6'
    }

    // Return an illustrative dot size (px) for a spectral class letter.
    // These sizes are purely pictorial (not to-scale) and chosen so hotter
    // stars appear distinct from cooler stars.
    function sizeForSpectral(letter) {
      if (!letter) return 10
      switch (letter.toUpperCase()) {
        case 'O': return 18
        case 'B': return 16
        case 'A': return 14
        case 'F': return 13
        case 'G': return 12
        case 'K': return 11
        case 'M': return 10
        default: return 10
      }
    }

    // Return a simple luminosity/class multiplier to make pictorial dots
    // reflect relative sizes: supergiants >> giants > main-sequence > dwarfs.
    // This is intentionally heuristic and conservative — it's only used to
    // make the dots look reasonable relative to one another (not to scale).
    function luminosityMultiplier(specStr, starTypeStr) {
      const spec = (specStr || '').toString().toUpperCase()
      const st = (starTypeStr || '').toString().toUpperCase()
      // Make the multipliers more conservative so circles remain pictorial
      // and don't dominate the layout. We'll rely primarily on these
      // modest factors and apply a separate, compressed radius-based
      // adjustment where needed.
      if (/SUPERGIANT|RED SUPERGIANT|YELLOW SUPERGIANT/i.test(st) || /IAB|IA|IB|SUPERGIANT/.test(spec)) return 2.0
      if (/BRIGHT GIANT|BRIGHT-GIANT/i.test(st) || /\bII\b/.test(spec)) return 1.8
      if (/GIANT/i.test(st) || /\bIII\b/.test(spec)) return 1.4
      if (/SUBGIANT/i.test(st) || /\bIV\b/.test(spec)) return 1.15
      if (/WHITE\s*-?DWARF/i.test(st) || /DA|DB|DQ|DC|DZ|D[A-Z]/.test(spec)) return 0.6
      // Main-sequence / dwarfs / generic
      if (/MAIN|V\b/.test(st) || /\bV\b/.test(spec)) return 1.0
      // Fallback: slightly upscale for luminous spectral letters (O/B)
      if (/O|B/.test(spec)) return 1.2
      return 1.0
    }

    // Ensure each star object has a numeric `numStars` property.
    // Only compute/assign `starType` when the data does not already provide one.
    // This preserves explicit/descriptive values written in `stars-data.js` (e.g. "Multiple (sextuple)").
    stars.forEach(s => {
      if (s.numStars == null) s.numStars = displayNumStars(s)
      const current = (s.starType || '').toString().trim()
      if (!current || current === '—') {
        // Only fill in when missing/placeholder
        s.starType = mostMassiveType(s)
      }
      // Ensure exoCount is a numeric field used for the "Exoplanets (confirmed)" column.
      if (!Number.isFinite(s.exoCount)) s.exoCount = s.exo ? 1 : 0
      // otherwise keep the author-provided `starType` exactly as given
    })

    // Update the page title and header with the current number of stars in the
    // dataset. This reads the global `stars` array (loaded from `stars-data.js`).
    function updateStarCount() {
      const n = Array.isArray(stars) ? stars.length : 0
      const el = document.getElementById('star-count')
      if (el) el.textContent = String(n)
      document.title = `Interactive Star Catalog — ${n} Brightest Stars`
    }

    // Set initial count immediately after dataset processing.
    updateStarCount()

    function visibleFilter(s) {
      const north = chkNorth.checked
      const south = chkSouth.checked
      if (north && south) return true // show all
      if (north && !south) return s.visibility === 'Northern' || s.visibility === 'Both'
      if (!north && south) return s.visibility === 'Southern' || s.visibility === 'Both'
      return false // none checked
    }

    function spectralStartsWithFilter(s) {
      const f = spectralFilter.value.trim()
      if (!f) return true
      return s.spectral.trim().toUpperCase().startsWith(f.toUpperCase())
    }

    function searchFilter(s) {
      const term = q.value.trim().toLowerCase()
      if (!term) return true
      const hay = (s.name + ' ' + s.constellation + ' ' + s.notes + ' ' + s.spectral + ' ' + s.starType).toLowerCase()
      return hay.includes(term)
    }

    function currentRows() {
      return stars
        .filter(visibleFilter)
        .filter(spectralStartsWithFilter)
        .filter(searchFilter)
        .slice()
        .sort(compare)
    }

    function render() {
      const rows = currentRows()
      tbody.innerHTML = rows.map(s => {
        // Show spectral-colored dots in the first column for either:
        //  - systems that provide a `components` array (one dot per component), or
        //  - single-star systems (numStars === 1) even when `components` is absent.
        // This avoids mass-editing `stars-data.js` while ensuring single stars
        // display a representative colored dot.
        const hasComponents = Array.isArray(s.components) && s.components.length > 0
        const isSingle = displayNumStars(s) === 1
        const showDot = hasComponents || isSingle
        let dotHtml = ''
        if (showDot) {
          const comps = hasComponents ? s.components : null
          // If components exist, render one dot per component. Otherwise,
          // render a single dot for the lone star using the system spectral type.
          const count = comps ? comps.length : 1
          let dots = ''
          // Special-case: for Castor we want all component dots to be small
          // and uniform (the user prefers six small stars). Detect by name.
          const isCastor = /castor/i.test(String(s.name))
          for (let i = 0; i < count; i++) {
            // Each component may be a string (spec) or an object {name, spec, visualSize}.
            const compEntry = comps ? comps[i] : s.spectral
            let compSpec = ''
            let compName = ''
            let forcedSize = null
            if (typeof compEntry === 'string') {
              compSpec = compEntry
            } else if (compEntry && typeof compEntry === 'object') {
              compSpec = compEntry.spec || ''
              compName = compEntry.name || ''
              forcedSize = compEntry.visualSize || null
            }
            // Parse the component spec first; if that fails try the system spectral entry.
            let parsed = parseSpectralPart((compSpec || '').toString())
            if (!parsed) parsed = parseSpectralPart((s.spectral || '').toString())
            const letter = parsed && parsed.letter ? parsed.letter : null
            const color = colorForSpectral(letter)
            // Determine size: prefer explicit visualSize, else for Castor fallback
            // to small uniform size if desired, otherwise use spectral size.
            let baseSize = forcedSize != null ? forcedSize : (isCastor ? 10 : sizeForSpectral(letter))
            if (!baseSize) baseSize = sizeForSpectral(letter)
            // Apply a luminosity/class multiplier so supergiants and giants
            // get visibly larger dots than main-sequence stars of the same
            // spectral letter. Use component-spec when available, else system
            // spectral/starType as fallback. To keep representations pictorial
            // (not to-scale), blend this spectral/multiplicity-based size with
            // a compressed radius-derived score so very large physical radii
            // (e.g., Betelgeuse) influence the dot but do not explode it.
            const compSpecForMult = (compSpec && compSpec.toString().trim()) || s.spectral || s.starType || ''
            const mult = luminosityMultiplier(compSpecForMult, s.starType)

            // Base pictorial size derived from spectral letter and luminosity class
            const pictorial = baseSize * mult

            // Compressed radius score: uses the system radius (most components
            // don't list individual radii). We compress via log10 and map to a
            // modest range so huge radii don't create gigantic circles.
            const sysRadius = Number(s.radius) || 1
            const cappedRadius = Math.min(sysRadius, 3000) // guard against absurd values
            const radiusScore = 8 + 9 * Math.log10(Math.max(1, cappedRadius)) // typical -> 8..~40

            // Blend pictorial and radius scores: weight radius somewhat higher
            // so truly enormous stars are recognizable, but keep everything
            // within a conservative visual range.
            let size = Math.round(0.4 * pictorial + 0.6 * radiusScore)

            // Clamp to reasonable visual bounds to avoid layout issues.
            size = Math.min(Math.max(size, 8), 44)
            const r = Math.max(2, Math.round(size / 2) - 1)
            // Add title for accessibility / quick tooltip with component name/spec
            let titleAttr = ''
            if (compName || compSpec) titleAttr = ' title="' + (compName ? compName + ' — ' : '') + compSpec + '"'
            dots += '<svg width="' + size + '" height="' + size + '" viewBox="0 0 ' + (r * 2 + 4) + ' ' + (r * 2 + 4) + '" xmlns="http://www.w3.org/2000/svg" class="rounded-full"' + titleAttr + '>'
            // Slightly stronger outline so pale fills (A/B/F) remain visible on a light background
            dots += '<circle cx="' + (r + 2) + '" cy="' + (r + 2) + '" r="' + r + '" fill="' + color + '" stroke="#0f172a" stroke-opacity="0.35" stroke-width="0.8"/>'
            dots += '</svg>'
            if (i < count - 1) dots += '<span class="mx-0.5" aria-hidden></span>'
          }
          // Prevent wrapping/overlap: keep dots on one line and add a small gap.
          dotHtml = '<span class="inline-flex items-center mr-2 align-middle" style="gap:6px; white-space:nowrap;" aria-hidden>' + dots + '</span>'
        }
        return `
        <tr class="hover:bg-slate-50">
          <td class="p-3 font-medium">${showDot ? ('<div class="flex flex-col items-center">' + dotHtml + '<div class="mt-1 font-medium text-center">' + s.name + '</div></div>') : ('<div class="font-medium">' + s.name + '</div>')}</td>
          <td class="p-3">${s.constellation}</td>
          <td class="p-3">${s.visibility}</td>
          <td class="p-3 text-right">${s.mag}</td>
          <td class="p-3 text-right">${displayNumStars(s)}</td>
          <td class="p-3 text-right">${formatNum(s.distance)}</td>
          <td class="p-3 text-right">${formatNum(s.lum)}</td>
          <td class="p-3 text-right">${formatNum(s.temp)}</td>
          <td class="p-3 text-right">${formatNum(s.radius)}</td>
          <td class="p-3 text-right">${formatNum(s.mass)}</td>
          <td class="p-3 text-right">${formatNum(s.age)}</td>
          <td class="p-3">${s.spectral}</td>
          <td class="p-3">${(() => {
            // If the system provides a `components` array, list each
            // component's spectral/type string so users can see the
            // composition at a glance. Otherwise fall back to the
            // author-provided `starType`.
            if (Array.isArray(s.components) && s.components.length) {
              return s.components.map(c => {
                if (typeof c === 'string') return c
                // prefer an explicit spec, otherwise the component name
                return (c.spec && c.spec.toString()) || (c.name && c.name.toString()) || '—'
              }).join(', ')
            }
            return s.starType || '—'
          })()}</td>
          <!-- Exoplanet count column removed; include planet info inside Notes popup below -->
          <td class="p-3" style="min-width:15rem;">
            <div class="relative inline-block group" tabindex="0">
              <!-- notes preview (short) -->
              ${(() => {
            const full = (s.notes || '').toString()
            // Append planet info into the full notes for visibility
            let extras = ''
            if (s.exoCount && Number(s.exoCount) > 0) extras += `Planets: ${s.exoCount}. `
            else if (s.exo) extras += `Planets: yes. `
            const preview = (full + ' ' + extras).trim().slice(0, 80)
            const more = (full + ' ' + extras).trim()
            // build popup content: notes + uncertainty + first source link if present
            let popup = '<div class="font-semibold">Details</div>' + '<div class="mt-1 text-sm">' + (more || '—') + '</div>'
            if (s.uncertainty && s.uncertainty.length) {
              popup += '<div class="mt-2 font-semibold">Uncertainty</div><div class="mt-1 text-sm">' + uncertaintyText(s) + '</div>'
            }
            if (s.sources && s.sources.length) {
              popup += '<div class="mt-2 text-xxs text-slate-300"><a href="' + s.sources[0] + '" target="_blank" rel="noopener" class="underline">source</a></div>'
            }
            return '<span class="text-sm text-slate-700">' + preview + (more.length > 80 ? '…' : '') + '</span>' +
              '<div class="absolute z-10 left-0 mt-2 w-80 max-w-[90vw] p-3 rounded-lg bg-white text-slate-900 text-sm shadow-sm border border-slate-100 opacity-0 pointer-events-none transition-opacity duration-150 group-hover:opacity-100 group-hover:pointer-events-auto hover:opacity-100 hover:pointer-events-auto focus:opacity-100 focus:pointer-events-auto" role="dialog" aria-hidden="true">' + popup + '</div>'
          })()}
            </div>
          </td>
        </tr>
      `}).join('')
      updateSortIndicators()
      // Keep the header/title in sync with the dataset each time we render
      // (useful if the stars array is modified programmatically at runtime).
      if (typeof updateStarCount === 'function') updateStarCount()
    }

    function updateSortIndicators() {
      document.querySelectorAll('th button').forEach(btn => {
        const ind = btn.querySelector('.sort-ind')
        if (!ind) return
        if (btn.dataset.key === sortKey) {
          ind.textContent = sortDir === 'asc' ? '▲' : '▼'
          ind.style.opacity = 1
        } else {
          ind.textContent = ''
          ind.style.opacity = .6
        }
      })
    }

    // --- Events ---
    document.querySelectorAll('th button').forEach(btn => {
      btn.addEventListener('click', () => {
        const key = btn.dataset.key
        if (sortKey === key) sortDir = (sortDir === 'asc') ? 'desc' : 'asc'
        else { sortKey = key; sortDir = 'asc' }
        render()
      })
    });

    [q, chkNorth, chkSouth, spectralFilter].forEach(el => el.addEventListener('input', render))

    // Initial render
    render();
  </script>
</body>

</html>